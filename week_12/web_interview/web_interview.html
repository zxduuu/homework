<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="web_interview.css">
    <title>Web_interview</title>
</head>
<body>
<div class="wrapper">

    <h1 class="head">前端工程师面试题</h1>
    <div>
        <h3>1.position的值， relative和absolute分别是相对于谁进行定位的？</h3>
        <ul>
            <li>absolute :生成绝对定位的元素， 相对于最近一级的 定位不是 static 的父元素来进行定位;</li>
            <li>fixed （老IE不支持）生成绝对定位的元素，通常相对于浏览器窗口或 frame 进行定位;</li>
            <li>relative 生成相对定位的元素，相对于其在普通流中的位置进行定位;</li>
            <li>static 默认值。没有定位，元素出现在正常的流中;</li>
            <li>sticky 生成粘性定位的元素，容器的位置根据正常文档流计算得出。</li>
        </ul>
    </div>
    <div>
        <h3>2.谈谈性能优化问题</h3>
        <p>代码层面：避免使用css表达式，避免使用高级选择器，通配选择器;</p>
        <p>缓存利用：缓存Ajax，使用CDN，使用外部js和css文件以便缓存，添加Expires头，服务端配置Etag，减少DNS查找等;</p>
        <p>请求数量：合并样式和脚本，使用css图片精灵，初始首屏之外的图片资源按需加载，静态资源延迟加载;</p>
        <p>请求带宽：压缩文件，开启GZIP;</p>
        <p>代码层面的优化:</p>
        <ul>
            <li>用 hash-table 来优化查找</li>
            <li>用 innerHTML 代替 DOM 操作，减少 DOM 操作次数，优化 javascript 性能</li>
            <li>用 setTimeout 来避免页面失去响应</li>
            <li>缓存DOM节点查找的结果</li>
            <li>避免使用CSS Expression</li>
            <li>避免全局查询</li>
            <li>避免使用with(with会创建自己的作用域，会增加作用域链长度)</li>
            <li>多个变量声明合并</li>
            <li>避免图片和iFrame等的空Src。空Src会重新加载当前页面，影响速度和效率</li>
            <li>尽量避免写在HTML标签中写Style属性</li>
        </ul>
        <p>移动端性能优化:</p>
        <ul>
            <li>尽量使用css3动画，开启硬件加速</li>
            <li>适当使用 touch 事件代替 click 事件</li>
            <li>避免使用 css3 渐变阴影效果</li>
            <li>可以用 transform: translateZ(0) 来开启硬件加速</li>
            <li>不滥用Float,Float在渲染时计算量比较大，尽量减少使用n</li>
            <li>不滥用Web字体,Web字体需要下载，解析，重绘当前页面，尽量减少使用</li>
            <li>合理使用requestAnimationFrame动画代替setTimeout</li>
            <li>CSS中的属性（CSS3 transitions、CSS3 3D transforms、Opacity、Canvas、WebGL、Video）会触发GPU渲染，请合理使用。过渡使用会引发手机过耗电增加
            </li>
            <li>PC端的在移动端同样适用</li>
        </ul>
    </div>


    <div>
        <h3>3.js继承方式及其优缺点</h3>
        <p>原型链继承的缺点:<br>
            一是字面量重写原型会中断关系，使用引用类型的原型，并且子类型还无法给超类型传递参数。</p>
        <p>借用构造函数（类式继承）:<br>
            借用构造函数虽然解决了刚才两种问题，但没有原型，则复用无从谈起。所以我们需要原型链+借用构造函数的模式，这种模式称为组合继承</p>
        <p>组合式继承:<>br
            组合式继承是比较常用的一种继承方法，其背后的思路是 使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。
            这样，既通过在原型上定义方法实现了函数复用，又保证每个实例都有它自己的属性。</p>
    </div>

    <div>
        <h3>4.用过哪些设计模式？</h3>
        <p>工厂模式：</p>
        <p>主要好处就是可以消除对象间的耦合，通过使用工程方法而不是new关键字。将所有实例化的代码集中在一个位置防止代码重复。
            工厂模式解决了重复实例化的问题 ，但还有一个问题,那就是识别问题，因为根本无法 搞清楚他们到底是哪个对象的实例。<br>
            function createObject(name,age,profession){//集中实例化的函数var obj = new Object();<br>
            obj.name = name;<br>
            obj.age = age;<br>
            obj.profession = profession;<br>
            obj.move = function () {<br>
            return this.name + ' at ' + this.age + ' engaged in ' + this.profession;<br>
            };<br>
            return obj;<br>
            }<br>
            var test1 = createObject('trigkit4',22,'programmer');//第一个实例var test2 =<br>
            createObject('mike',25,'engineer');//第二个实例</p>

        <p>构造函数模式：

            使用构造函数的方法 ，即解决了重复实例化的问题 ，又解决了对象识别的问题，该模式与工厂模式的不同之处在于：</p>
        <ul>
            <li>1.构造函数方法没有显示的创建对象 (new Object());</li>
            <li>2.直接将属性和方法赋值给 this 对象;</li>
            <li>3.没有 renturn 语句。</li>
        </ul>
    </div>

    <div>
        <h3>5.说说你对闭包的理解:</h3>
        <p>使用闭包主要是为了设计私有的方法和变量。
            闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。
            在js中，函数即闭包，只有函数才会产生作用域的概念。<br>
            闭包有三个特性：</p>
        <ul>
            <li>1.函数嵌套函数</li>
            <li>2.函数内部可以引用外部的参数和变量</li>
            <li>3.参数和变量不会被垃圾回收机制回收</li>
        </ul>
    </div>

    <div>
        <h3>6.CSS中 link 和 @import 的区别是？</h3>
        <ul>
            <li>link属于HTML标签，而@import是CSS提供的;</li>
            <li>页面被加载的时，link会同时被加载，而@import被引用的CSS会等到引用它的CSS文件被加载完再加载;</li>
            <li>import只在IE5以上才能识别，而link是HTML标签，无兼容问题;</li>
            <li>link方式的样式的权重 高于@import的权重。</li>
        </ul>
    </div>

    <div>
        <h3>7.CSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3新增伪类有那些？</h3>
        1).id选择器（ # myid )<br>
        2).类选择器（.myclassname） <br>
        3).标签选择器（div, h1, p）<br>
        4).相邻选择器（h1 + p）<br>
        5).子选择器（ul > li）<br>
        6).后代选择器（li a）<br>
        7).通配符选择器（ * ）<br>
        8).属性选择器（a[rel = "external"]）<br>
        9).伪类选择器（a: hover, li:nth-child）<br>

        <p>优先级为:<br>
            !important &gt; id &gt; class &gt; tag<br>
            important 比 内联优先级高,但内联比 id 要高
        </p>
        <p>CSS3新增伪类举例：</p>
        <ul>
            <li>p:first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素;</li>
            <li>p:last-of-type 选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p> 元素</li>
            <li>p:only-of-type 选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素</li>
            <li>p:only-child 选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素</li>
            <li>p:nth-child(2) 选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素</li>
            <li>:enabled :disabled 控制表单控件的禁用状态</li>
            <li>:checked 单选框或复选框被选中</li>
        </ul>
    </div>

    <div>
        <h3>8.CSS3有哪些新特性？</h3>

        <p>
            CSS3实现圆角（border-radius），阴影（box-shadow），对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform）;<br>
            transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);//旋转,缩放,定位,倾斜<br>
            增加了更多的CSS选择器 多背景 rgba<br>
            在CSS3中唯一引入的伪元素是::selection.<br>
            媒体查询，多栏布局<br>
            border-image<br>
            CSS3中新增了一种盒模型计算方式： box-sizing 。盒模型默认的值是 content-box , 新增的值是 padding-box 和 border-box ，几种盒模型计算元素宽高的区别如下：<br>
            content-box（默认）<br>
            布局所占宽度Width：<br>
            Width = width + padding-left + padding-right + border-left + border-right<br>
            布局所占高度Height:<br>
            Height = height + padding-top + padding-bottom + border-top + border-bottom<br>
            padding-box<br>
            布局所占宽度Width：<br>
            Width = width(包含padding-left + padding-right) + border-top + border-bottom<br>
            布局所占高度Height:<br>
            Height = height(包含padding-top + padding-bottom) + border-top + border-bottom<br>
            border-box<br>
            布局所占宽度Width：<br>
            Width = width(包含padding-left + padding-right + border-left + border-right)<br>
            布局所占高度Height:<br>
            Height = height(包含padding-top + padding-bottom + border-top + border-bottom)
        </p>
    </div>

    <div>
        <h3>9.说说你对语义化的理解？</h3>
        <ul>
            <li>去掉或者丢失样式的时候能够让页面呈现出清晰的结构</li>
            <li>有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重</li>
            <li>方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页</li>
            <li>便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化</li>
        </ul>
    </div>

    <div>
        <h3>10.常见兼容性问题？</h3>
        <p>png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.也可以引用一段脚本处理。<br>
            浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一。<br>
            IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。<br>
            浮动ie产生的双倍距离（IE6双边距问题：在IE6下，如果对元素设置了浮动，同时又设置了margin-left或margin-right，margin值会加倍。）<br>
            #box{ float:left; width:10px; margin:0 0 0 100px;}<br>
            这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入_display:inline;将其转化为行内属性。(_这个符号只有ie6会识别)
            渐进识别的方式，从总体中逐渐排除局部。首先，巧妙的使用“\9”这一标记，将IE游览器从所有情况中分离出来。接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。<br>
            css<br>
            .bb{<br>
            background-color:#f1ee18;/*所有识别*/<br>
            .background-color:#00deff\9; /*IE6、7、8识别*/<br>
            +background-color:#a200ff;/*IE6、7识别*/<br>
            _background-color:#1e0bd1;/*IE6识别*/<br>
            }<br>
            怪异模式问题：漏写DTD声明，Firefox仍然会按照标准模式来解析网页，但在IE中会触发怪异模式。为避免怪异模式给我们带来不必要的麻烦，
            最好养成书写DTD声明的好习惯。现在可以使用[html5](http://www.w3.org/TR/html5/single-page.html)推荐的写法：`&lt;doctype html&gt;`
        </p>
    </div>

    <div>
        <h3>11.解释下浮动和它的工作原理？清除浮动的技巧</h3>
        <p>
            浮动元素脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留。<br>
            1.使用空标签清除浮动。<br>
            这种方法是在所有浮动标签后面添加一个空标签 定义css clear:both. 弊端就是增加了无意义标签。<br>
            2.使用overflow。<br>
            给包含浮动元素的父标签添加css属性 overflow:auto; zoom:1; zoom:1用于兼容IE6。<br>
            3.使用after伪对象清除浮动。<br>
            该方法只适用于非IE浏览器。具体写法可参照以下示例。使用中需注意以下几点。一、该方法中必须为需要清除浮动元素的伪对象中设置 height:0，否则该元素会比实际高出若干像素。<br>
            4.浮动外部元素。 (需要再理解下)
        </p>
    </div>

    <div>
        <h3>12.浮动元素引起的问题和解决办法？</h3>
        <p>浮动元素引起的问题：<br>
            （1）父元素的高度无法被撑开，影响与父元素同级的元素<br>
            （2）与浮动元素同级的非浮动元素（内联元素）会跟随其后<br>
            （3）若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构
            解决方法：<br>
            使用 CSS 中的 clear:both ;属性来清除元素的浮动可解决2、3问题，对于问题1，添加如下样式，给父元素添加 clearfix 样式：<br>
            .clearfix:after{content: ".";display: block;height: 0;clear: both;visibility: hidden;}<br>
            .clearfix{display: inline-block;}.
        </p>
    </div>

    <div>
        <h3>13.DOM操作——怎样添加、移除、移动、复制、创建和查找节点?</h3>
        <p>1）创建新节点<br>
            createDocumentFragment() //创建一个DOM片段<br>
            createElement() //创建一个具体的元素<br>
            createTextNode() //创建一个文本节点<br>
            2）添加、移除、替换、插入<br>
            appendChild()<br>
            removeChild()<br>
            replaceChild()<br>
            insertBefore() //并没有insertAfter()<br>
            3）查找<br>
            getElementsByTagName() //通过标签名称<br>
            getElementsByName() //通过元素的Name属性的值(IE容错能力较强，<br>
            会得到一个数组，其中包括id等于name值的)<br>
            getElementById() //通过元素Id，唯一性<br>
        </p>
    </div>

    <div>
        <h3>14.new操作符具体干了什么呢?</h3>
        <p> 1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。<br>
            2、属性和方法被加入到 this 引用的对象中。<br>
            3、新创建的对象由 this 所引用，并且最后隐式的返回 this。<br>

            var obj = {};<br>
            obj.__proto__ = Base.prototype;<br>
            Base.call(obj);</p>
    </div>

    <div>
        <h3>15.call() 和 apply() 的区别和作用？</h3>
        <p>作用：动态改变某个类的某个方法的运行环境（执行上下文）。<br>
            区别：方法传递的参数不同。</p>
    </div>

    <div>
        <h3>16.哪些操作会造成内存泄漏？</h3>
        <p>内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。<br>
            垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。<br>
            setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。<br>
            闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）
        </p>
    </div>

    <div>
        <h3>17.GET和POST的区别，何时使用POST？</h3>
        <p>GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符<br>
            POST：一般用于修改服务器上的资源，对所发送的信息没有限制。<br>
            GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值，
            也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
            然而，在以下情况中，请使用 POST 请求：<br>
        <ul>
            <li>无法使用缓存文件（更新服务器上的文件或数据库）</li>
            <li>向服务器发送大量数据（POST 没有数据量限制）</li>
            <li>发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</li>
        </ul>
        </p>
    </div>

    <div>
        <h3>18.说说严格模式的限制。</h3>
        <p>严格模式主要有以下限制：<br>
            变量必须声明后再使用<br>
            函数的参数不能有同名属性，否则报错<br>
            不能使用with语句<br>
            不能对只读属性赋值，否则报错<br>
            不能使用前缀0表示八进制数，否则报错<br>
            不能删除不可删除的属性，否则报错<br>
            不能删除变量delete prop，会报错，只能删除属性delete global[prop]<br>
            eval不会在它的外层作用域引入变量<br>
            eval和arguments不能被重新赋值<br>
            arguments不会自动反映函数参数的变化<br>
            不能使用arguments.callee<br>
            不能使用arguments.caller<br>
            禁止this指向全局对象<br>
            不能使用fn.caller和fn.arguments获取函数调用的堆栈<br>
            增加了保留字（比如protected、static和interface）<br>
            设立"严格模式"的目的，主要有以下几个：<br>
            消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为;<br>
            消除代码运行的一些不安全之处，保证代码运行的安全；<br>
            提高编译器效率，增加运行速度；<br>
            为未来新版本的 Javascript 做好铺垫。
        </p>
    </div>

    <div>
        <h3>19.创建ajax的过程?</h3>
        <p>(1)创建`XMLHttpRequest`对象,也就是创建一个异步调用对象.<br>
            (2)创建一个新的`HTTP`请求,并指定该`HTTP`请求的方法、`URL`及验证信息.<br>
            (3)设置响应`HTTP`请求状态变化的函数.<br>
            (4)发送`HTTP`请求.<br>
            (5)获取异步调用返回的数据.<br>
            (6)使用JavaScript和DOM实现局部刷新.<br>
            var xmlHttp = new XMLHttpRequest();<br>
            xmlHttp.open('GET','demo.php','true');<br>
            xmlHttp.send()<br>
            xmlHttp.onreadystatechange = function(){<br>
            if(xmlHttp.readyState === 4 & xmlHttp.status === 200){
              }
            }
        </p>
    </div>


    <div>
        <h3>20.对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？</h3>
        <p>前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近。<br>
            1、实现界面交互<br>
            2、提升用户体验<br>
            3、有了Node.js，前端可以实现服务端的一些事情<br>
            前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好，<br>
            参与项目，快速高质量完成实现效果图，精确到1px；<br>
            与团队成员，UI设计，产品经理的沟通；<br>
            做好的页面结构，页面重构和用户体验；<br>
            处理hack，兼容、写出优美的代码格式；<br>
            针对服务器的优化、拥抱最新前端技术。
        </p>
    </div>
</div>
</body>
</html>